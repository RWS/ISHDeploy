<#
    .SYNOPSIS
        Performs Set or Remove relying parties

    .DESCRIPTION
        This commandlet provides basic functionality to set or remove relying parties based on generated information from input parameters.

    .PARAMETER  Computer
        Specifies computer name to open a persistent connection (PSSession) to. The default is the local computer.

    .PARAMETER  Session
        Specifies [PSSession] session object to use.

    .PARAMETER  Action
        Either `Set` or `Remove`

    .EXAMPLE
        $s01 = New-PSSession -ComputerName "10.91.5.39"
        Invoke-ADFSIntegrationISH -Session $s01 -Action "Set"

    .EXAMPLE
        Invoke-ADFSIntegrationISH -Computer "10.91.5.39" -Action "Set"

    .EXAMPLE
         $s03 = New-PSSession -ComputerName "10.91.5.39"
        Invoke-ADFSIntegrationISH -Session $s03 -Action "Remove"

    .EXAMPLE
        Invoke-ADFSIntegrationISH -Computer "10.91.5.39" -Action "Remove"

    .INPUTS
        None. You cannot pipe objects to Invoke-ADFSIntegrationISH.ps1.

    .OUTPUTS
        None. Invoke-ADFSIntegrationISH.ps1 does not generate any output.
#>
Param(
	[parameter(Mandatory=$false)]
	$Computer=$null,
	[parameter(Mandatory=$false)]
	$Session=$null,
	[parameter(Mandatory=$true)]
    [ValidateSet("Set","Remove")]
	$Action
)	
 
#region variables generated by the deployment
#Host for the services [baseurl->basehostname]
$basehostname="#!#installtool:BASEHOSTNAME#!#"
#Application Name [projectsuffix]
$projectsuffix="#!#installtool:PROJECTSUFFIX#!#"
#Windows Account Name for delegated requests [osuser]
$osuser="#!#installtool:OSUSER#!#"
#InfoShareAuthor Web Application Name [infoshareauthorwebappname]
$infoshareauthorwebappname="#!#installtool:INFOSHAREAUTHORWEBAPPNAME#!#"
#InfoShareWS Web Application Name [infosharewswebappname]
$infosharewswebappname="#!#installtool:INFOSHAREWSWEBAPPNAME#!#"
#endregion
 
if($Action -eq "Set")
{
    #Encryption Certificate. (Required for WebServices Relying Parties)
    $certInfoShareWSPath="$PSScriptRoot\ishws.cer"
    if(!(Test-Path $certInfoShareWSPath))
    {
	    Write-Error "$certInfoShareWSPath is not a valid Certificate path"
	    EXIT 1
    }
    $certInfoShareWS=new-object System.Security.Cryptography.X509Certificates.X509Certificate2
    #Load if from a filepath
    try
    {
	    $certInfoShareWS.import("$PSScriptRoot\ishws.cer") 
    }
    catch 
    [System.Exception]
    {
	    Write-Error -Exception $_.Exception
	    EXIT 1
    }
}
 
$setBlock = {
    #Check if block is executing remotely
    if($PSSenderInfo) {
        $DebugPreference=$Using:DebugPreference
        $VerbosePreference=$Using:VerbosePreference
 
        $basehostname=$Using:basehostname
        $projectsuffix=$Using:projectsuffix
        $osuser=$Using:osuser
        $infoshareauthorwebappname=$Using:infoshareauthorwebappname
        $infosharewswebappname=$Using:infosharewswebappname
        $certInfoShareWS=$Using:certInfoShareWS
    }
    $newLine=[Environment]::NewLine
 
    Function WriteDebugWithHeaderFooter
    {
	    Param (
	    [string]$header,
	    [string] $message
	    )
	    $header="<--- $header --->"
	    $footer="<"+("-"*($header.Length-2))+">"
	    $message=$message.Trim($newLine)
	    Write-Debug "$newLine$header$newLine$message$newLine$footer$newLine"
    }
 
    Function RenderKeyValue
    {
	    Param ([string]$name,[object]$value)
	    if($value -is [string])
	    {
		    return "[$name] $value$newLine"
	    }
	    else
	    {
		    return "[$name]$newLine$value$newLine"
	    }
    }
 
    #Transform variables from InstallTool
    #------------------------------------
    $serviceHost=$basehostname.Replace("https://","").Replace("http://","")
    $actorWindowsAccountName=$osuser
    $infoShareAuthor=$infoshareauthorwebappname
    $infoShareWS=$infosharewswebappname
 
    #Prepare information for the Relying Parties
    #-------------------------------------------
 
    #1.InfoShareAuthor
    #-----------------
    #Relying Party Name
    $nameInfoShareAuthor="SDL.ISH - $serviceHost - $infoShareAuthor"
    #Relying Party Identifier 
    $identifierInfoShareAuthor="https://$serviceHost/$infoShareAuthor/"
    #WS-Federation endpoint
    $wsfedepInfoShareAuthor="https://$serviceHost/$infoShareAuthor/"
 
 
    #1.InfoShareWS
    #-------------
    #Relying Party Name
    $nameInfoShareWS="SDL.ISH - $serviceHost - $infoShareWS"
    #Relying Party Identifier (One for every WCF service) 
    $templateIdentifierInfoShareWS=@(
		    "https://{0}/$infoShareWS/Wcf/API25/Application.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/Baseline.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/DocumentObj.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/EDT.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/EventMonitor.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/Folder.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/ListOfValues.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/MetadataBinding.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/OutputFormat.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/PublicationOutput.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/Search.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/Settings.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/TranslationJob.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/TranslationTemplate.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/User.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/UserGroup.svc",
		    "https://{0}/$infoShareWS/Wcf/API25/UserRole.svc",
 
		    "https://{0}/$infoShareWS/Wcf/API20/Application.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/DocumentObj.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/EDT.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/Folder.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/MetaDataAssist.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/OutputFormat.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/Publication.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/PublicationOutput.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/Reports.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/Search.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/Settings.svc",
		    "https://{0}/$infoShareWS/Wcf/API20/Workflow.svc",
 
		    "https://{0}/$infoShareWS/Wcf/API/Application.svc",
		    "https://{0}/$infoShareWS/Wcf/API/ConditionManagement.svc"
	    )
 
    
    $identifierInfoShareWS="https://$serviceHost/$infoShareWS/"
    $identifierSetInfoShareWS=@()
    $identifierSetInfoShareWS+=$identifierInfoShareWS
    foreach($templateIdentifierWS in $templateIdentifierInfoShareWS)
    {
	    $identifierSetInfoShareWS+=$templateIdentifierWS -f $basehostname
    }
 
    #Prepare Claims Transformation Rules
    #-----------------------------------
 
    #1.Issuance Transform Rules (First Tab in Rellying Party Claims Rules)
    #------------------------------------------------------------------
    #Windows Account Claim
    #Generates the http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname with the value from Active Directory
    $windowsAccountClaim='
    @RuleTemplate = "PassThroughClaims"
    @RuleName = "Windows Account Name"
    c:[Type == "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname"]
    => issue(claim = c);'
			
    #Windows Account To Name Claim
    #Generates the http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name with values like Domain\User
    $windowsAccountToNameClaim='
    @RuleTemplate = "MapClaims"
    @RuleName = "Windows Account Name => Name"
    c:[Type == "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname"]
    => issue(Type = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name", Issuer = c.Issuer, OriginalIssuer = c.OriginalIssuer, Value = c.Value, ValueType = c.ValueType);'
					   
    #Sum of rules
    $issuanceTransformRules=$windowsAccountClaim+$newLine+$windowsAccountToNameClaim
 
 
    #2.Issuance Authorization Rules (Second Tab in Rellying Party Claims Rules)
    #--------------------------------------------------------------------------
    #Rule to Permit everyone
    $permitAllUsersClaim='
    @RuleTemplate = "AllowAllAuthzRule"
    => issue(Type = "http://schemas.microsoft.com/authorization/claims/permit", Value = "true");'
    #Sum of rules
    $issuanceAuthorizationRules=$permitAllUsersClaim
 
    #3.Delegation Authorization Rules (Third Tab in Rellying Party Claims Rules)
    #--------------------------------------------------------------------------
    #Rule to Permit everyone
    $authorizeActor='
    @RuleTemplate = "Authorization"
    @RuleName = "Allow Delegation From '+$actorWindowsAccountName+'"
    c:[Type == "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname", Value =~ "^(?i)'+$actorWindowsAccountName.Replace("\", "\\")+'$"]
    => issue(Type = "http://schemas.microsoft.com/authorization/claims/permit", Value = "PermitUsersWithClaim");'
    #Sum of rules
    $delegationAuthorizationRules=$authorizeActor
 
    #Write Information
    #InfoShareAuthor
    $infoInfoShareAuthor= RenderKeyValue "Name" $nameInfoShareAuthor
    $infoInfoShareAuthor+= RenderKeyValue "Identifier" $identifierInfoShareAuthor
    $infoInfoShareAuthor+= RenderKeyValue "WS-Federation Endpoint" $wsfedepInfoShareAuthor
    WriteDebugWithHeaderFooter "Relying Party Information for $infoShareAuthor" $infoInfoShareAuthor
 
    #InfoShareWS
    $infoInfoShareWS= RenderKeyValue "Name" $nameInfoShareWS
    $infoInfoShareWS+= RenderKeyValue "Encryption Certificate" ("[Subject]"+$certInfoShareWS.Subject)
    $infoInfoShareWS+= RenderKeyValue "Encryption Certificate" ("[SerialNumber]"+$certInfoShareWS.SerialNumber)
    $infoInfoShareWS+= RenderKeyValue "Encryption Certificate" ("[Thumbprint]"+$certInfoShareWS.Thumbprint)
    $identifierSetInfoShareWS |foreach {$infoInfoShareWS+= RenderKeyValue "Identifier" $_}
    WriteDebugWithHeaderFooter "Relying Party Information for $infoShareWS" $infoInfoShareWS
 
    #Issuance Transform Rules
    WriteDebugWithHeaderFooter "Relying Party Issuance Transform Rules" $issuanceTransformRules
 
    #Log Issuance Authorization Rules
    WriteDebugWithHeaderFooter "Relying Party Issuance Authorization Rules" $issuanceAuthorizationRules
 
    #Log Delegation Authorization Rules
    WriteDebugWithHeaderFooter "Relying Party Delegation Authorization Rules" $delegationAuthorizationRules
 
    
    #Clear Existing Relying Parties
    #Check if Relying Party for InfoShareAuthor exists
    $rpInfoShareAuthor=Get-ADFSRelyingPartyTrust -Identifier $identifierInfoShareAuthor
    if(-not $rpInfoShareAuthor)
    {
        Add-ADFSRelyingPartyTrust -Name $nameInfoShareAuthor -Identifier $identifierInfoShareAuthor -WSFedEndpoint $wsfedepInfoShareAuthor -IssuanceTransformRules $issuanceTransformRules -IssuanceAuthorizationRules $issuanceAuthorizationRules -TokenLifetime 600
	    Write-Verbose "Relying party with name $nameInfoShareAuthor created."
    }
 
    #Check if Relying Party for InfoShareWS exists and then remove
    $rpInfoShareWS=Get-ADFSRelyingPartyTrust -Identifier $identifierInfoShareWS
    if(-not $rpInfoShareWS)
    {
        Add-ADFSRelyingPartyTrust -Name $nameInfoShareWS -Identifier $identifierSetInfoShareWS -EncryptionCertificate  $certInfoShareWS -IssuanceTransformRules $issuanceTransformRules -IssuanceAuthorizationRules $issuanceAuthorizationRules -DelegationAuthorizationRules $delegationAuthorizationRules
	    Write-Verbose "Relying party with name $nameInfoSharWS created."
    }
    else
    {
        Set-ADFSRelyingPartyTrust -TargetIdentifier $identifierInfoShareWS -EncryptionCertificate  $certInfoShareWS -Identifier $identifierSetInfoShareWS 
	    Write-Verbose "Relying party with name $($rpInfoShareWS.Name) updated."
    }
 
}
 
$removeBlock = {
    #Check if block is executing remotely
    if($PSSenderInfo) {
        $DebugPreference=$Using:DebugPreference
        $VerbosePreference=$Using:VerbosePreference
 
        $basehostname=$Using:basehostname     
        $infoshareauthorwebappname=$Using:infoshareauthorwebappname
        $infosharewswebappname=$Using:infosharewswebappname
    }
 
    #Transform variables from InstallTool
    #------------------------------------
    $serviceHost=$basehostname.Replace("https://","").Replace("http://","")
    $infoShareAuthor=$infoshareauthorwebappname
    $infoShareWS=$infosharewswebappname
 
    #1.InfoShareAuthor
    #-----------------
    #Relying Party Identifier 
    $identifierInfoShareAuthor="https://$serviceHost/$infoShareAuthor/"
 
    #1.InfoShareWS
    #-------------
    #Relying Party Identifier (Using as key the Wcf/API25/Application.svc) 
    $identifierInfoShareWS="https://$serviceHost/$infoShareWS/"
 
    #Clear Existing Relying Parties
    #Check if Relying Party for InfoShareAuthor exists and then remove
    $rpInfoShareAuthor=Get-ADFSRelyingPartyTrust -Identifier $identifierInfoShareAuthor
    if($rpInfoShareAuthor -ne $null)
    {
	    $nameInfoShareAuthor=$rpInfoShareAuthor.Name
	    Remove-ADFSRelyingPartyTrust -TargetIdentifier $identifierInfoShareAuthor
	    Write-Verbose "Relying party with name $($rpInfoShareAuthor.Name) deleted."
    }
    else
    {
	    Write-Warning "Relying Party for Identifier $identifierInfoShareAuthor not found"
    }
    #Check if Relying Party for InfoShareWS exists and then remove
    $rpInfoShareWS=Get-ADFSRelyingPartyTrust -Identifier $identifierInfoShareWS
    if($rpInfoShareWS -ne $null)
    {
	    $nameInfoShareWS=$rpInfoShareWS.Name
	    Remove-ADFSRelyingPartyTrust -TargetIdentifier $identifierInfoShareWS
	    Write-Verbose "Relying party with name $($rpInfoShareWS.Name) deleted."
    }
    else
    {
	    Write-Warning "Relying Party for Identifier $identifierInfoShareWS not found"
    }
 
}
 
 
switch($Action) {
    "Set" {
        $name="Set Relying Parties"
        $block=$setBlock
    }
    "Remove" {
        $name="Remove Relying Parties"
        $block=$removeBlock
    }
}
 
 
try
{
    $mustRemoveSession=$false
    if(-not ($Session) -and $Computer)
    {
        $Session=New-PSSession $Computer
        $mustRemoveSession=$true
    }
 
    if($Session)
    {
        Write-Debug "[$name] Start on $($Session.ComputerName)"
        Invoke-Command -Session $Session -ScriptBlock $block
        Write-Verbose "[$name] Done on $($Session.ComputerName)"
 
    }
    else
    {
        Write-Debug "[$name] Start"
        Invoke-Command -ScriptBlock $block
        Write-Verbose "[$name] Done"
    }
}
finally
{
    if($mustRemoveSession)
    {
        Remove-PSSession $Session
    }
}